<!doctype html>  
<html lang="ko">
	
	<head>
		<meta charset="utf-8">
		
		<title>현재 자바스크립트 표준은 어디쯤?</title>

		<meta name="description" content="Javascript Standard of 2012 about comonjs, amd with node.js, arudino and require.js">
		<meta name="author" content="Denny Lim<hello@iamdenny.com>">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
		
		<link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
		
		<link rel="stylesheet" href="css/main.css">
		<link rel="stylesheet" href="css/theme/default.css">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<script>
			// If the query includes 'print-pdf' we'll use the PDF print sheet
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>
	
	<body>
		
		<div class="reveal">

			<!-- Used to fade in a background when a specific slide state is reached -->
			<div class="state-background">
				<div id="logo">
					<a href="http://www.nts-corp.com" target="_blank" class="image">
						<img src="./img/nts_logo.png" alt="NHN Technology Services." title="Go to NHN Technology Services.">
					</a>
				</div>
			</div>
			
			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>현재 자바스크립트 표준은 어디쯤?</h1>
					<h3>Javascript Standard of 2012</h3>
					<p id="author">
						Denny Lim &lt;hello@iamdenny.com&gt<br>&lt;iamdenny@nhn.com&gt;
					</p>

					<aside class="notes">
						안녕하세요. 컨버전스UI개발팀 임대현입니다.<br>
						인식이 많이 바뀌긴 했지만, 아직까지 잘못 이해되고 있는 언어가 있습니다. <br>
						바로 자바스크립트입니다.<br>
						대부분 자바스크립트는 깜빡이는 글자, 흘러가는 글자, 마우스 올렸을 때 사진이 바꿔주는 기능, <br>
						소스 보지 못하게 마우스 오른쪽 클릭 막는 일등등 이였지요.<br>
						현재의 자바스크립트는 어떤가요?<br>
						Ajax 통신을 통해 페이지 리프레시 없이 하는 기능은 물론이며, 워드, 엑셀, 그림 그리기등<br>
						응용프로그램에서만 할 수 있었던 일들을 자바스크립트가 웹브라우저상에서 가능하게 해주고 있습니다.<br>
						또한 클라이언트 사이드용만이 아닌 서버 사이드 언어로도 사용되기에 안성 맞춤입니다.<br>
						Node.js 라는 것인데, 조금 있다가 살짝 보여드리도록 하겠습니다.<br>
						이렇게 점점 웹소프트웨어가 커져가는데 점점 이슈가 나타나기 시작합니다.<br>
						자바스크립트 표준이 있었다면 많은 문제점들이 해결될 수 있텐데요,<br>
						현재 그 표준이 어디쯤에 와 있는지 앞으로 살펴 보도록 하겠습니다.
					</aside>
				</section>
				
				<!-- Example of nested vertical slides -->
				
				<section>
					<h2>객체</h2>
					<ul>
						<li class="fragment">철학</li>
						<li class="fragment">문법</li>
						<li class="fragment">추상</li>
						<li class="fragment">수학</li>
						<li class="fragment">컴퓨터과학</li>
						<li class="fragment"><a href="#/2">객체지향 프로그램밍</a></li>
					</ul>

					<aside class="notes">
						본론으로 들어가기에 앞서 객체에 대해서 잠깐 말씀 드리겠습니다.<br>
						위키피디아에서 정의하기를<br>
						철학 : 존재 또는 개념<br>
						문법 : 직접적인 개체 또는 문장 요소<br>
						추상 : 특정 시간이나 장소에 존재하지 않는 객체<br>
						수학 : 수학에서 발생하는 추상 객체<br>
						컴퓨터과학 : 데이터 작업 방법과 데이터 바인딩을 위한 언어 메카니즘<br>
						음,, 뭔가 말이 어렵습니다.<br>
						객체지향 프로그램밍 : 객체 클래스 또는 배열의 인스턴스라고 정의합니다.<br>
						객체지향 프로그래밍에 대해 알아보겠습니다.
					</aside>
				</section>
				<section>
					<h2>객체지향 프로그래밍</h2>
					
					<img src="http://expressionflow.com/wp-content/uploads/2007/04/object-hierarchy.png">
					<aside class="notes">
						객체지향 프로그래밍은 Object Oriented Programming, 줄여서 OOP 라고 합니다.<br>
						위키백과에서는 컴퓨터 프로그래밍의 패러다임 중 하나라고 하며,<br>
						컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위,<br>
						즉, '객체'들의 모임으로 파악하고자 하는 것이라고 합니다.<br>
						뭐 어쨌거나 저쨌거나,
					</aside>
				</section>
				<section>
					<h2>왜 OOP를 해야 할까?</h2>
					<br>
					<ul>
						<li class="fragment">배우기 쉽다</li>
						<li class="fragment">유지보수 용이</li>
						<li class="fragment">직관적인 코드</li>
					</ul>

					<aside class="notes">
						왜 OOP를 해야 할까요?<br>
						프로그래밍을 더 배우기 쉽게 하고 개발과 유지보수를 간편하게 하며,<br>
						보다 직관적인 코드 분석을 가능하게 합니다.<br>
						또한, 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용됩니다.<br>
						그러나, 지나친 객체화는 또다른 문제점을 야기하기도 하지만,<br>
						아무튼 다른 개발 방법론보다는 좋은 것 같습니다.
					</aside>
				</section>

				<section>
					<section>
						<h2>OOP의 특징</h2>

						<img src="http://cfile22.uf.tistory.com/image/204E831F4CA35FC85DA059" border="1">
						<aside class="notes">
							OOP는 기본적으로 상속, 다형성, 추상화, 캡슐화등이 있습니다.<br>
							상속은 부모와 자식 개념으로 다들 알고 계실 것이구요<br>
							다형성은 어떤 한 요소에 여러 개념을 넣어 놓는 것으로 일반적으로 오버라이딩이나 오버로딩을 말합니다.<br>
							정보은닉은 프로그래밍을 배워보신 분들은 아실 것입니다.<br>							
							이 중 캡슐화를 좀 더 살펴보면요
						</aside>
					</section>
					<section>
						<h2>캡슐화</h2>
						<br>
						<blockquote cite="http://en.wikipedia.org/wiki/Encapsulation_(object-oriented_programming)">
						A language mechanism for restricting access to some of the object's components
						</blockquote>
						<aside class="notes">
							위키피디아에서는 캡슐화를 이렇게 정의합니다.<br>
							직역하면, 객체요소에 접근 제한을 하기 위한 언어 매카니즘이다.<br>
							즉, 외부에서 보이지도 않고, 접근도 못하게 하는 것입니다.<br>
							그리고 캡슐화는 정보은닉과 밀접한 관련이 있습니다.<br>
							정보은닉은 멤버변수에 private, public, protected 를 지정한 후, get, set을 이용하여,<br>
							외부에서 직접 변수를 접근하지 못하게 하는 정도라는 것만 알아두시구요.
						</aside>
					</section>
					<section>
						<h2>왜 캡슐화가 필요하지?</h2>
						<br>
						<p class="fragment">원하지 않는 무언가로부터 변수를 보호한다.</p>

						<aside class="notes">
							그럼 왜 캡슐화가 필요할까요?<br>
							이유는 간단합니다.<br>
							원하지 않는 무언가로부터 변수를 보호하기 위함입니다.
						</aside>
					</section>
				</section>

				<section>
					<h2>자바스크립트는<br><br>프로토타입 언어다</h2>

					<aside class="notes">
						이제, 자바스크립트 얘기를 하겠습니다.<br>
						OOP 방법론에는 두가지 구조가 있는데요<br>
						그 중 하나가 여러분이 잘 알고 계시는 클래스 타입의 OOP입니다.<br>
						그리고 프로토타입 OOP가 있구요.
						자바스크립트는 프로토타입 언어입니다.							
					</aside>
				</section>

				<section>
					<h2>Private Data</h2>
					
					<a href="http://coolprogramming.springnote.com/pages/3421999.xhtml" target="_blank">
						<img src="http://coolprogramming.springnote.com/pages/3421999/attachments/1775259">
					</a>

					<aside class="notes">
						자바스크립트도 캡슐화, 정보은닉이 가능하구요.<br>
						몇가지 예를 보여드리겠습니다.
					</aside>
				</section>

				<section>
					<section>
						<h2>코딩 컨벤션</h2>
						<br>
						<pre><code contenteditable>
function Human(sGender){
	//Private
	this._nAge = 1;
	this._sGender = sGender || 'Male';

	//Public
	this.growUp = function(){
		this._nAge++;
	}
}
						</code></pre>

						<aside class="notes">
							코딩 컨벤션에서는 변수명 앞에 언더스코어를 붙여서 Private Data를 명시하고 있습니다.							
						</aside>
					</section>

					<section>
						<h2>어디서든 접근가능</h2>						
						
						<img src="img/naming_convention.png">
						<aside class="notes">
							코딩 컨벤션은 컨벤션일뿐, 외부에서 모두 접근이 가능합니다.<br>
							캡슐화가 안되는 것이지요
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>특권(Privileged) 메소드</h2>
						<br>

						<pre><code contenteditable>
function Human(sTempGender){
	//Private
	var nAge = 1,
	    sGender = sTempGender || 'Male';

	//Privileged Method
	this.growUp = function(){
		nAge++;
	}
}
						</code></pre>
					
						<aside class="notes">
							age와 genter를 var 키워드로 선언하였고,<br>
							this.growUp 메소드에서 age를 증가시키는 코드입니다.
						</aside>
					</section>

					<section>
						<h2>일부 접근가능</h2>					
						
						<img src="img/privileged_method.png">
						<aside class="notes">
							age와 gender는 이제 외부에서 접근이 불가능하고<br>
							growUp 메소드를 통해서만 가능합니다.<br>
							단, this라는 키워드를 사용하기 위해서는 꼭 new 키워드를 이용하여<br>
							인스턴스를 생성하여야 합니다.						
						</aside>
					</section>
				</section>
				
				<section data-state="soothe">
					<h2>모듈 패턴</h2>
					
					<img src="http://zannabi.thoth.kr/files/attach/images/4105250/223/665/005/module.jpg">
					<aside class="notes">
						모듈 패턴은 어떻게 하는지 보여드리겠습니다.
					</aside>
				</section>

				<section>
					<section>
						<h1>모듈 패턴</h1>

						<pre><code contenteditable>
function Human(sTempGender){
	//Private
	var nAge = 1,
	    sGender = sTempGender || 'Male';

	//Public
	return {
		growUp : function(){
			nAge++;
		}
	}
}
						</code></pre>

						<aside class="notes">
							Privileged 메소드 방법과 유사하지만, 다른 형태입니다.<br>
							this 키워드가 사라지고, 대신 함수를 티턴할 때, growUp 메소드를 반환합니다.<br>
						</aside>
					</section>

					<section>
						<h2>접근 가능</h2>
						
						<img src="img/module_pattern.png">
						<aside class="notes">
							Privileged 메소드 방법과 마찬가지로, growUp 메소드만 접근 가능합니다.<br>	다른점은 this 키워드가 없고, 인스턴스를 만들지 않는다는 것입니다.
						</aside>
					</section>
				</section>
				<section>
					<section>
						<h2>장점</h2>
						<br>
						<ul>
							<li>쉽다</li>
							<li>Private Data가 안전하다</li>
						</ul>

						<aside class="notes">
							모듈화의 장점으로는<br>
							쉽고, private data를 안전하게 유지 할 수 있습니다.
						</aside>
					</section>

					<section>
						<h2>단점</h2>
						<br>
						<ul>
							<li>상속이 어렵다.</li>
						</ul>

						<aside class="notes">
							단점으로는 상속이 약간 어려워집니다.
						</aside>
					</section>
				</section>
					
				<section>
					<section>
						<h2>대형 프로젝트</h2>
						<br>
						<ul>
							<li>수많은 모듈</li>
							<li>복잡한 의존성</li>
						</ul>

						<aside class="notes">
							대형 프로젝트에서는 수많은 모듈과, 복잡한 의존성에 대한 이슈가 있을 것입니다.<br>
							먼저 수많은 모듈은 어떤 이슈인지 살펴 보겠습니다.
						</aside>
					</section>

					<section>
						<h2>수많은 모듈</h2>
						<br>
						<ul>
							<li>파일 하나에 모듈 하나</li>
							<li>많은 파일들에 대한 이슈
								<ul>
									<li>성능 이슈</li>
									<li>비동기 로딩</li>
								</ul>
							</li>
						</ul>

						<aside class="notes">
							파일 하나에 모듈 하나의 원칙을 따라야 하는데,<br>
							이렇게 되면 자연히 파일들이 많아 질 것이고,<br>
							성능에 대한 이슈와 필요한 모듈을 그때 그때 로딩해야하는<br>
							비동기 로딩 이슈가 생기게 됩니다.
						</aside>
					</section>

					<section>
						<h2>복잡한 의존성</h2>
						<br>
						<ul>
							<li>불러올 모듈의 순서</li>
							<li>수동으로 순서를 지정하기 힘듬</li>
						</ul>

						<aside class="notes">
							복잡한 의존성을 살펴보면,<br>
							분명 모듈을 불러올 때도, 순서대로 불러와야 하는 이슈가 있을 것이고<br>
							그 순서를 수동으로 하기에는 한계가 있습니다.
						</aside>
					</section>

					<section>
						<h2>해결책은?</h2>
						<br>
						<ul>
							<li class="fragment">어렵지 않다.</li>
							<li class="fragment">다만, 표준이 없을 뿐.</li>
						</ul>

						<aside class="notes">
							해결책은 의외로 간단합니다.<br>
							다만, 모두가 따르고 준수할 표준이 없을 뿐입니다.
						</aside>
					</section>
				</section>	
			
				<section data-state="soothe">
					<br><br><br><br>
					<img class="noborder" src="http://wiki.commonjs.org/images/3/3a/Website-Logo.png" width="350">

					<aside class="notes">
						그래서 CommonJS라는 것이 등장합니다.<br>
						JavaScript를 브라우저에서뿐만 아니라,<br>
						서버사이드 애플리케이션이나 데스크톱 애플리케이션에서도 사용하려고 조직한 자발적 워킹 그룹입니다.
					</aside>
				</section>
			
				<section>
					<h2>CommonJS APIs</h2>
					<ul>
						<li>Binary</li>
						<li>Console</li>
						<li>Encoding</li>
						<li>Filesystem</li>
						<li>IO</li>
						<li>Modules</li>
						<li>Packages</li>
						<li>Promises</li>
					</ul>

					<aside class="notes">
						CommonJs API들 입니다.
					</aside>
				</section>
			
				<section>
					<h2>CommonJS Modules</h2>
					<ul>
						<li>Modules/1.0 <span class="fragment"><a href="#/16">: Node.js</a></span></li>
						<li>Modules/1.1</li>
						<li>Modules/1.1.1</li>
					</ul>

					<aside class="notes">
						CommonJs의 모듈로는 1.0, 1.1, 1.1.1가 명세되어 있습니다.<br>
						이 중 1.0은 Node.js에 의해 구현 되었습니다.<br>
						잠깐 Node.js 살펴보고 넘어가보겠습니다.
					</aside>
				</section>
			
				<section>
					<section>
						<a href="http://nodejs.org" target="_blank"><img src="http://behrang.github.com/presentations/node.js/2011-09-07/pictures/cover.png" width="600"></a>
						<aside class="notes">
							Node.js는 요즘 새로운 트랜드라서 좀 들어보셨을 것입니다.<br>
							라이언 달이라는 Joyent 회사의 개발자분이 만들었습니다.<br>
							Node.js는 자바스크립트를 서버 사이드 언어로 가능하게 합니다.<br>
							그리고 큰 특징은 기존의 멀티 스레드와 블록 방식과는 반대로<br>
							싱글 스레드와 논블럭 이벤트 방식으로 작동됩니다.<br>
							우선 간단히 어떻게 작동 되는지 보여드리겠습니다.
						</aside>
					</section>

					<section>
						<h2>웹서버 제작</h2>
						<pre><code contenteditable>
var http = require('http');
http.createServer(function (req, res) {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('Hello World\n');
}).listen(1337, '127.0.0.1');
console.log('Server running at http://127.0.0.1:1337/');
						</code></pre>

						<aside class="notes">
							이렇게만 하고 실행을하면, 바로 웹서버가 실행됩니다.<br>
							만약 자바로 한다면, 위의 코드도 필요한 뿐더러 아파치와 톰캣이 필요할 것입니다.<br>
							아주 흥미로운 것을 하나 더 소개해 드리겠습니다.
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2 class="fragment">Arduino</h2>
						
						<a href="http://www.arduino.cc" target="_blank">
							<img src="http://arduino.cc/en/uploads/Main/arduino_uno_test.jpg">
						</a>
						<aside class="notes">
							아두이노라는 것인데요<br>
							2005년 아틸리아 이브레아(Ivrea)에서 학생들에게 적합한 인터렉션 디자인 프로젝트를<br>
							수행하기 위한 제어장치로 디자이너 마시모 밴지(Massimo Banzi)와<br>
							다비드 쿠아르티에예스(David Cuartielles)에 의해 만들어졌습니다.<br>
							아두이노의 뜻은 '강한 친구'라는 의미로 많은 이탈리아 남성의 이름이라고도 합니다.<br>
							그리고 아두이노는 여러개의 제품을 가지고 있는데요,<br>
							우선 제가 보여드리는 것은 아두이노 우노 라는 것입니다.<br>
							기본적으로 아두이노는 C언어로 작성하게 되어 있습니다.<br>
							우선 한번 보여드리겠습니다.
						</aside>
					</section>

					<section>
						<h2>breakout.js를 이용한 예제</h2>
							
						<a href="http://breakoutjs.com/" target="_blank">
							<img src="http://breakoutjs.com/wp-content/uploads/2012/02/how_breakout_works.png">
						</a>
						<a href="http://localhost" target="_blank">
							http://localhost:8888
						</a>
						<aside class="notes">
							Node.js를 이용하면, 자바스크립트로도 제어가 가능합니다.<br>
							그리고 벌써 아두이노를 위한 자바스크립트 프레임워크들이 속속들이 개발되고 있는데요.<br>
							그 중 breakout.js 라는 툴을 이용해서 LED를 켜고 끄는 것을 보여드리겠습니다.						
						</aside>
					</section>
				</section>
				
				<section data-state="soothe">
					<h2 class="middle">AMD</h2>
					
					<aside class="notes">
						AMD 그룹은 비동기 상황에서도 JavaScript 모듈을 쓰기 위해 CommonJS에서 함께 논의하다가<br>
						합의점을 이루지 못하고 독립한 그룹입니다.<br>
						본래 CommonJS가 JavaScript를 브라우저 밖으로 꺼내기 위한 노력의 일환으로 탄생했기 때문에<br>
						브라우저 내에서의 실행에 중점을 두었던 AMD와는 합의를 이끌어 내지 못하고 결국 둘이 분리되었습니다<br>
						CommonJS 공식 위키에도 AMD가 독립했다는 사실을 알리고 있습니다.

					</aside>
				</section>
				
				<section>
					<h2>Asychronous Module Definition</h2>
					<br>
					<pre><code contenteditable>
define(id?, dependencies?, factory);
					</code></pre>

					<aside class="notes">
						다시한번 말씀드리는데, CommonJS와 AMD는 어떠한 프레임워크가 아닌,<br>
						표준을 만들어 놓은 명세일 뿐입니다.<br>
						사용법은 보시는바와 같이 define, 정의 한다라고 명시하고<br>
						첫번째 인자에는 해당 모듈의 아이디,<br>
						두번째 인자에는 해당 모듈이 필요로하는 다른 모듈의 정보, 의존성이지요<br>
						세번짼 인자는 모듈의 코드를 삽입하는 부분입니다.
					</aside>
				</section>
				
				<section>
					<section>
						<h2>사용법</h2>
						
						<pre><code contenteditable>
define(
	'account',
	['service', 'pubsub'],
	function(service, pubsub){
		// Private Code

		// export public APIs
		return {
			signIn : function(){},
			signOut : function() {},
			getName : function() {},
			setName : function() {}
		}
	}
);
						</code></pre>

						<aside class="notes">
							모듈의 아이디는 account 이고,<br>
							의존모듈은 service와 pubsub이 있습니다.<br>
							그리고 의존 모듈을 인자값으로 받아 온다음,<br>
							내부 코드를 작성하고 있습니다.
						</aside>
					</section>
				
					<section>
						<h2>다른 방법</h2>
						<br>
						<pre><code contenteditable>
(function(){
	// Private Code

	exports = {
		signIn : function(){},
		signOut : function() {},
		getName : function() {},
		setName : function() {}
	};

	define('account', function(){
		return exports;
	}
}());
						</code></pre>
						<aside class="notes">
							이렇게도 작성이 가능합니다.
						</aside>
					</section>
					
					<section>
						<h2>Jindo &amp; jQuery</h2>
						<br>
						<pre><code contenteditable>
define('jindo', [], function() {return jindo;} );
						</code></pre>
						<br>
						<pre><code contenteditable>
define('jquery', [], function() {return jQuery;} );
						</code></pre>

						<aside class="notes">
							Jindo나 jQuery는 이렇게 코드 한줄 삽입하면, 모듈로써 사용하실 수 있습니다.
						</aside>
					</section>
				</section>
				
				<section>
					<h2>RequireJs</h2>
					<br>
					<a href="http://requrejs.org" target="_blank">
						<img src="http://requirejs.org/i/logo.png">
					</a>
				</section>
				
				<section>
					<h2>RequireJS</h2>
					<br>
					<ul>
						<li>AMD 구현 by James Burke</li>
						<li>비동기 로딩</li>
						<li>2.0.5</li>
					</ul>

					<aside class="notes">
						RequreJS는 제임스에 의해 AMD명세를 코드로 구현했습니다.<br>
						비동기 로딩을 지원하며, 현재 2.0.5 버전을 배포하고 있습니다.
					</aside>
				</section>

				<section>
					<section>
						<h2>사용법</h2>
						<br>
						<pre><code contenteditable>
&lt;script type="text/javascript" src="require.js"&gt;&lt;/script&gt;
						</code></pre>	
						
						<br>
						<pre><code contenteditable>
&lt;script type="text/javascript" src="main.js"&gt;&lt;/script&gt;
						</code></pre>	
						
						<aside class="notes">
							한 줄만 html 파일에 추가하시면 됩니다.							
						</aside>
					</section>
					
					<section>
						<h2>main.js</h2>
						<br>
						<pre><code contenteditable>
require(['app'], function(app){
	app.init();
});
						</code></pre>
						
						<aside class="notes">
							main.js라고 했는데, 편하실대로 파일이름을 생성하시고<br>
							html 파일에 첨부하시면 됩니다.
						</aside>
					</section>
					
					<section>
						<h2>app.js</h2>
						<br>

						<pre><code contenteditable>
define(['lib/account', 'lib/sesstion'],
	function(account, session){
		// 내부 코드

		return {
			init : function(){}
		}
	}
);
						</code></pre>

						<aside class="notes">
							main.js에서 불러왔던 app.js 파일이구요<br>
							여기서는 account와 session을 필요로하고 있으며<br>
							init 함수를 린턴 합니다.
						</aside>
					</section>
					
					<section>
						<img src="img/tree.png">

						<aside class="notes">
							소스 코드는 다 보여드릴 필요는 없을 것 같구요.<br>
							대략 이런 트리구조 형태로 모듈화가 됩니다.
						</aside>
					</section>
				</section>
				
				<section>
					<section>
						<h2>장점</h2>
						<br>
						<ul>
							<li>클로벌 스코프 문제 해결</li>
							<li>모든 것은 모듈안에서 작동</li>
							<li>커피스크립트로도 컴파일 가능</li>
							<li>플러그인을 지원함</li>
						</ul>

						<aside class="notes">
							자바스크립트를 해보셨으면, 클로저 프로퍼티라는 것을 들어보셨을 것입니다.<br>
							스코프 문제가 있었는데요, 그 문제가 해결되구요<br>
							모듈안에서 모든 것들이 작동을 합니다<br>
							그리고 커피스크립트나 기타 플러그인을 사용 가능하구요<br>
						</aside>
					</section>

					<section>
						<h2>단점</h2>
						<br>

						<ul>
							<li>모듈 로딩 실패시 디버깅이 어렵다.
								<ul>
									<li>잘못된 모듈 경로 설정</li>
									<li>플러그인 에러</li>
								</ul>
							</li>
						</ul>
						<aside class="notes">
							단점으로는 모듈 로딩 실패시 디버깅이 어렵습니다<br>
							원인으로는 잘못된 모듈 경로를 설정 했을 때나<br>
							혹 플러그인 에러가 있을때 찾기 힘듭니다
						</aside>
					</section>

					<section>
						<h2>여전히 풀리지 않은 문제</h2>
						<br>
						
						<ul>
							<li>수많은 모듈들</li>
							<li>수많은 파일들</li>
							<li>수많은 요청들</li>
							<li>성능 저하</li>
						</ul>

						<aside class="notes">
							앞전에 대형 프로젝트에서의 이슈가 여전히 풀리지는 않았습니다.<br>
							풀어야할 과제로 남아있구요<br>
							이 뜻은 앞으로 자바스크립트가 더욱 더 발전 할 수 있다는 의미인 것 같습니다.<br>
							제 발표는 여기까지 입니다.
						</aside>
					</section>
				</section>
				
				<section>
					<br><br><br>
					<h1>Gracias</h1>
					<h4>BY Denny Lim</h4>
				</section>
			</div>

			<!-- The navigational controls UI -->
			<aside class="controls">
				<a class="left" href="#">&#x25C4;</a>
				<a class="right" href="#">&#x25BA;</a>
				<a class="up" href="#">&#x25B2;</a>
				<a class="down" href="#">&#x25BC;</a>
			</aside>

			<!-- Presentation progress bar -->
			<div class="progress"><span></span></div>
			
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>
			
			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/linear(2d)

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/highlight.js', async: true, callback: function() { window.hljs.initHighlightingOnLoad(); } },
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'lib/js/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'lib/js/data-markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'socket.io/socket.io.js', async: true, condition: function() { return window.location.host === 'localhost:1947'; } },
					{ src: 'plugin/speakernotes/client.js', async: true, condition: function() { return window.location.host === 'localhost:1947'; } },
				]
			});

			Reveal.addEventListener( 'customevent', function() {
				//alert( '"customevent" has fired' );
			} );
			
		</script>

	</body>
</html>
